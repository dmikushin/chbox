#!/usr/bin/env python3
import argparse
import sys
import os
import pty
import re
import subprocess

def find_paths_matching_regex(regex_pattern):
    paths = []
    regex = re.compile(regex_pattern)

    # Extract the starting part of the regex to determine the search directory
    start_dir = os.path.dirname(regex_pattern)

    for dirpath, dirnames, filenames in os.walk(start_dir):
        for name in dirnames + filenames:
            path = os.path.join(dirpath, name)
            if regex.match(path):
                paths.append(path)

    return paths


def is_valid_regex(pattern):
    # List of regex metacharacters
    metacharacters = ['\\', '.', '[', ']', '|', '(', ')', '{', '}', '^', '$', '*', '+', '?']

    # Check if the pattern contains any regex metacharacters
    for metachar in metacharacters:
        if metachar in pattern:
            return True

    return False


def execute_bwrap_command(command_line):
    # Create a pseudo-terminal (pty) pair
    master_fd, slave_fd = pty.openpty()

    # Execute the bash shell process
    bash_process = subprocess.Popen(command_line, stdin=slave_fd, stdout=slave_fd, stderr=slave_fd, close_fds=True)

    # Close the slave file descriptor as it is no longer needed in the parent process
    os.close(slave_fd)

    # Main loop for interacting with the shell
    while True:
        try:
            # Read from the master file descriptor
            output = os.read(master_fd, 1024)
            if not output:
                break  # If the output is empty, the shell process has exited
            # Process the output or perform any desired operations
            print(output.decode(), end='')  # Print the output to the console

            # Process any input from the user
            user_input = input()
            # Write the user input to the master file descriptor
            os.write(master_fd, user_input.encode())
        except KeyboardInterrupt:
            # If the user presses Ctrl+C, gracefully terminate the shell process
            break

    # Wait for the shell process to finish
    bash_process.wait()

    # Return the return code of the executed command
    return bash_process.returncode


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='bwrap',
                                     usage='%(prog)s [OPTIONS...] [--] COMMAND [ARGS...]',
                                     description='bwrap - container setup utility (regex extension)',
                                     add_help=False)

    parser.add_argument('--help', action='help', help='Print this help')
    parser.add_argument('--version', action='store_true', help='Print version')
    parser.add_argument('--args', metavar='FD', help='Parse NUL-separated args from FD')
    parser.add_argument('--unshare-all', action='store_true', help='Unshare every namespace we support by default')
    parser.add_argument('--share-net', action='store_true', help='Retain the network namespace (can only combine with --unshare-all)')
    parser.add_argument('--unshare-user', action='store_true', help='Create new user namespace (may be automatically implied if not setuid)')
    parser.add_argument('--unshare-user-try', action='store_true', help='Create new user namespace if possible else continue by skipping it')
    parser.add_argument('--unshare-ipc', action='store_true', help='Create new ipc namespace')
    parser.add_argument('--unshare-pid', action='store_true', help='Create new pid namespace')
    parser.add_argument('--unshare-net', action='store_true', help='Create new network namespace')
    parser.add_argument('--unshare-uts', action='store_true', help='Create new uts namespace')
    parser.add_argument('--unshare-cgroup', action='store_true', help='Create new cgroup namespace')
    parser.add_argument('--unshare-cgroup-try', action='store_true', help='Create new cgroup namespace if possible else continue by skipping it')
    parser.add_argument('--userns', metavar='FD', help='Use this user namespace (cannot combine with --unshare-user)')
    parser.add_argument('--userns2', metavar='FD', help='After setup switch to this user namespace, only useful with --userns')
    parser.add_argument('--disable-userns', action='store_true', help='Disable further use of user namespaces inside sandbox')
    parser.add_argument('--assert-userns-disabled', action='store_true', help='Fail unless further use of user namespace inside sandbox is disabled')
    parser.add_argument('--pidns', metavar='FD', help='Use this pid namespace (as parent namespace if using --unshare-pid)')
    parser.add_argument('--uid', metavar='UID', help='Custom uid in the sandbox (requires --unshare-user or --userns)')
    parser.add_argument('--gid', metavar='GID', help='Custom gid in the sandbox (requires --unshare-user or --userns)')
    parser.add_argument('--hostname', metavar='NAME', help='Custom hostname in the sandbox (requires --unshare-uts)')
    parser.add_argument('--chdir', metavar='DIR', help='Change directory to DIR')
    parser.add_argument('--clearenv', action='store_true', help='Unset all environment variables')
    parser.add_argument('--setenv', metavar=('VAR', 'VALUE'), nargs=2, action='append', help='Set an environment variable')
    parser.add_argument('--unsetenv', metavar='VAR', action='append', help='Unset an environment variable')
    parser.add_argument('--lock-file', dest='lock_file', metavar='DEST', help='Take a lock on DEST while sandbox is running')
    parser.add_argument('--sync-fd', dest='sync_fd', metavar='FD', help='Keep this fd open while sandbox is running')
    parser.add_argument('--bind', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Bind mount the host path SRC on DEST')
    parser.add_argument('--bind-try', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Equal to --bind but ignores non-existent SRC')
    parser.add_argument('--dev-bind', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Bind mount the host path SRC on DEST, allowing device access')
    parser.add_argument('--dev-bind-try', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Equal to --dev-bind but ignores non-existent SRC')
    parser.add_argument('--ro-bind', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Bind mount the host path SRC readonly on DEST')
    parser.add_argument('--ro-bind-try', metavar=('SRC', 'DEST'), nargs=2, action='append', help='Equal to --ro-bind but ignores non-existent SRC')
    parser.add_argument('--remount-ro', dest='remount_ro', metavar='DEST', help='Remount DEST as readonly; does not recursively remount')
    parser.add_argument('--exec-label', dest='exec_label', metavar='LABEL', help='Exec label for the sandbox')
    parser.add_argument('--file-label', dest='file_label', metavar='LABEL', help='File label for temporary sandbox content')
    parser.add_argument('--proc', metavar='DEST', help='Mount new procfs on DEST')
    parser.add_argument('--dev', metavar='DEST', help='Mount new dev on DEST')
    parser.add_argument('--tmpfs', metavar='DEST', help='Mount new tmpfs on DEST')
    parser.add_argument('--mqueue', metavar='DEST', help='Mount new mqueue on DEST')
    parser.add_argument('--dir', metavar='DEST', help='Create dir at DEST')
    parser.add_argument('--file', nargs=2, metavar=('FD', 'DEST'), action='append', help='Copy from FD to destination DEST')
    parser.add_argument('--bind-data', nargs=2, metavar=('FD', 'DEST'), action='append', help='Copy from FD to file which is bind-mounted on DEST')
    parser.add_argument('--ro-bind-data', nargs=2, metavar=('FD', 'DEST'), action='append', help='Copy from FD to file which is readonly bind-mounted on DEST')
    parser.add_argument('--symlink', nargs=2, metavar=('SRC', 'DEST'), action='append', help='Create symlink at DEST with target SRC')
    parser.add_argument('--seccomp', nargs=1, metavar='FD', action='append', help='Load and use seccomp rules from FD (not repeatable)')
    parser.add_argument('--add-seccomp-fd', dest='add_seccomp_fd', nargs=1, metavar='FD', action='append', help='Load and use seccomp rules from FD (repeatable)')
    parser.add_argument('--block-fd', dest='block_fd', metavar='FD', help='Block on FD until some data to read is available')
    parser.add_argument('--userns-block-fd', dest='userns_block_fd', metavar='FD', help='Block on FD until the user namespace is ready')
    parser.add_argument('--info-fd', dest='info_fd', metavar='FD', help='Write information about the running container to FD')
    parser.add_argument('--json-status-fd', dest='json_status_fd', metavar='FD', help='Write container status to FD as multiple JSON documents')
    parser.add_argument('--new-session', action='store_true', help='Create a new terminal session')
    parser.add_argument('--die-with-parent', action='store_true', help="Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.")
    parser.add_argument('--as-pid-1', action='store_true', help='Do not install a reaper process with PID=1')
    parser.add_argument('--cap-add', nargs=1, metavar='CAP', action='append', help='Add cap CAP when running as privileged user')
    parser.add_argument('--cap-drop', nargs=1, metavar='CAP', action='append', help='Drop cap CAP when running as privileged user')
    parser.add_argument('--perms', metavar='OCTAL', help='Set permissions of next argument (--bind-data, --file, etc.)')
    parser.add_argument('--size', metavar='BYTES', help='Set size of next argument (only for --tmpfs)')
    parser.add_argument('--chmod', nargs=2, metavar=('OCTAL', 'PATH'), action='append', help='Change permissions of PATH (must already exist)')

    parser.add_argument('command', nargs=argparse.REMAINDER, help='Command to be executed followed by its arguments')

    args = parser.parse_args()

    # Access the parsed values as needed
    if getattr(args, 'help', False):
        parser.print_help()
        sys.exit()

    if not args.command:
        parser.print_help()
        sys.exit()

    dash = None
    if args.command[0] == '--':
        args.command = args.command[1:]
        dash = '--'
    if not args.command:
        parser.print_help()
        sys.exit()

    # Create new_args to hold the content of args
    new_args = []

    # Expand the options with SRC and DEST, which are defined
    # with regular expressions.
    for arg, values in vars(args).items():
        if not values:
            continue

        if not arg in ('bind', 'bind-try', 'dev-bind', 'dev-bind-try', 'ro-bind', 'ro-bind-try', 'symlink'):
            continue

        for value in values:
            # If SRC is not a regex, then just keep this option as is.
            src = value[0]
            if not is_valid_regex(src):
                new_args.append((arg, value))
                continue

            # We've got a regex in SRC, now we need to do the following:
            # 1) Find all files in the filesystem that are matching the regex
            # 2) Compute the replacement file for all matched filenames
            # 3) Add each match and replacement as an individual option
            dest = value[1]
            paths = find_paths_matching_regex(src)
            for path in paths:
                replacement = re.sub(src, dest, path)
                new_value = (path, replacement)
                new_args.append((arg, new_value))

    # Expand the options with DEST or PATH, which are defined
    # with regular expressions.
    for arg, values in vars(args).items():
        if not values:
            continue

        if not arg in ('remount-ro', 'chmod'):
            continue

        for value in values:
            # If DEST is not a regex, then just keep this option as is.
            dest = value
            if not is_valid_regex(dest):
                new_args.append((arg, value))
                continue

            # We've got a regex in SRC, now we need to do the following:
            # 1) Find all files in the filesystem that are matching the regex
            # 2) Add each match as an individual option
            paths = find_paths_matching_regex(re.escape(dest))
            for path in paths:
                new_args.append((arg, path))

    # Add all the rest
    for arg, values in vars(args).items():
        if not values:
            continue

        if not arg in ('bind', 'bind-try', 'dev-bind', 'dev-bind-try', 'ro-bind', 'ro-bind-try', 'symlink', 'remount-ro', 'chmod'):
            if isinstance(values, list):
                for value in values:
                    new_args.append((arg, value))
                continue
            else:
                new_args.append((arg, values))


    # Substitute args with new_args and use it in the same
    # way as the original args
    args = argparse.Namespace()
    for arg, value in new_args:
        if not hasattr(args, arg):
            setattr(args, arg, [value])
        else:
            getattr(args, arg).append(value)

    # Reconstruct the command line string: first convert
    # the args object into a list of command-line arguments
    command_line = [ parser.prog ]
    for arg, value in vars(args).items():
        arg = re.sub('_', '-', arg)
        if value is not None and arg not in ('help', 'version', 'command') and value != parser.get_default(arg):
            if isinstance(value, list):
                for item in value:
                    command_line.append(f'--{arg}')
                    if isinstance(item, list):
                        command_line.extend(item)
                    elif isinstance(item, bool):
                        pass
                    else:
                        command_line.append(item)
            else:
                command_line.append(f'--{arg}')
                if not isinstance(value, bool):
                    command_line.append(value)

    if dash:
        command_line.append(dash)
    command_line.extend(args.command)

    # Check if TEST_BWRAPX environment variable is defined
    if os.environ.get('TEST_BWRAPX'):
        # If TEST_BWRAPX is defined, print the final command line for testing
        print(' '.join(command_line))
    else:
        # If TEST_BWRAPX is not defined, execute the bwrap command
        print(' '.join(command_line))
        return_code = execute_bwrap_command(command_line)
        sys.exit(return_code)

